var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ManualMemory","category":"page"},{"location":"#ManualMemory","page":"Home","title":"ManualMemory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ManualMemory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ManualMemory]","category":"page"},{"location":"#ManualMemory.LazyPreserve","page":"Home","title":"ManualMemory.LazyPreserve","text":"LazyPreserve(x, ptrcall=nothing)\n\nUsed by preserve to identify arguments that will be unwrapped with preserve_buffer, which is in turn converted to a pointer. If ptrcall is specified conversion to a pointer occurs through a call equivalent to ptrcall(preserve_buffer(x), x). Otherwise, a call equivalent to pointer(preserve_buffer(x)) occurs.\n\n\n\n\n\n","category":"type"},{"location":"#ManualMemory.PseudoPtr","page":"Home","title":"ManualMemory.PseudoPtr","text":"PseudoPtr(data, position=firstindex(data))\n\nProvides a convenient wrapper that functions like pointer(data) for instances where data cannot produce a viable pointer.\n\n\n\n\n\n","category":"type"},{"location":"#ManualMemory.preserve-Tuple{Any, Vararg{Any}}","page":"Home","title":"ManualMemory.preserve","text":"preserve(op, args...; kwargs...)\n\nSearches through args and kwargs for instances of LazyPreserve, which are unwrapped using preserve_buffer and preserved from garbage collection (GC.@preserve). the resulting buffers are converted to pointers and passed in order to op.\n\nExamples\n\njulia> using ManualMemory: store!, preserve, LazyPreserve\n\njulia> x = [0 0; 0 0];\n\njulia> preserve(store!, LazyPreserve(x), 1)\n\njulia> x[1]\n1\n\n\n\n\n\n\n","category":"method"},{"location":"#ManualMemory.preserve_buffer-Tuple{ManualMemory.LazyPreserve}","page":"Home","title":"ManualMemory.preserve_buffer","text":"preserve_buffer(x)\n\nFor structs wrapping arrays, using GC.@preserve can trigger heap allocations. preserve_buffer attempts to extract the heap-allocated part. Isolating it by itself will often allow the heap allocations to be elided. For example:\n\njulia> using StaticArrays, BenchmarkTools\njulia> # Needed until a release is made featuring https://github.com/JuliaArrays/StaticArrays.jl/commit/a0179213b741c0feebd2fc6a1101a7358a90caed\n       Base.elsize(::Type{<:MArray{S,T}}) where {S,T} = sizeof(T)\njulia> @noinline foo(A) = unsafe_load(A,1)\nfoo (generic function with 1 method)\njulia> function alloc_test_1()\n           A = view(MMatrix{8,8,Float64}(undef), 2:5, 3:7)\n           A[begin] = 4\n           GC.@preserve A foo(pointer(A))\n       end\nalloc_test_1 (generic function with 1 method)\njulia> function alloc_test_2()\n           A = view(MMatrix{8,8,Float64}(undef), 2:5, 3:7)\n           A[begin] = 4\n           pb = parent(A) # or `LoopVectorization.preserve_buffer(A)`; `perserve_buffer(::SubArray)` calls `parent`\n           GC.@preserve pb foo(pointer(A))\n       end\nalloc_test_2 (generic function with 1 method)\njulia> @benchmark alloc_test_1()\nBenchmarkTools.Trial:\n  memory estimate:  544 bytes\n  allocs estimate:  1\n  --------------\n  minimum time:     17.227 ns (0.00% GC)\n  median time:      21.352 ns (0.00% GC)\n  mean time:        26.151 ns (13.33% GC)\n  maximum time:     571.130 ns (78.53% GC)\n  --------------\n  samples:          10000\n  evals/sample:     998\njulia> @benchmark alloc_test_2()\nBenchmarkTools.Trial:\n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     3.275 ns (0.00% GC)\n  median time:      3.493 ns (0.00% GC)\n  mean time:        3.491 ns (0.00% GC)\n  maximum time:     4.998 ns (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1000\n\n\n\n\n\n","category":"method"}]
}
